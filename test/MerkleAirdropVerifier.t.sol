// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../contracts/MerkleAirdropVerifier.sol";

contract MerkleAirdropVerifierTest is Test {
    using stdJson for string;

    MerkleAirdropVerifier verifier;

    // Proof for address 0x00000000000000c0d7d3017b342ff039b55b0879 (leaf index 0)
    // Generated by merkle_proof.py against merkle.db in this repo.
    address constant SAMPLE_ADDR = 0x00000000000000C0D7D3017B342ff039B55b0879;
    bytes32 constant SAMPLE_LEAF =
        0x834f1183cb3c8164a86d50e7e2c717f67cb26d0044a3844dd2eac58a79159be9;
    bytes32[] proof;
    bool[] directions;

    function setUp() public {
        verifier = new MerkleAirdropVerifier();
        proof = new bytes32[](26);
        directions = new bool[](26);

        proof[0] = 0x0359da021b010dc77f21cacb7102533b9b5f16c5d5b7518421d3810421c91196;
        proof[1] = 0xe7e7969d1c76761e6db13b29edf0191211b776d2b26e11abe16b6a2b27a56ff5;
        proof[2] = 0xb8abe4e17cd7afead15a10c4918163829671b93aea9600911dab0b8204a47911;
        proof[3] = 0x7687087ccf9b1614eebbe6b0da28c7df255b9264118119a4b131c3ee5d52e06e;
        proof[4] = 0xb3b54fc68040565a85a8e4175c75cfb4768eee74fa5a3691d6baabcea75b21fb;
        proof[5] = 0x98f3ae8db548d203d9e14323ece3930c3023cbc95b977f9e4ee0401ff3b1b800;
        proof[6] = 0xa4962c303b6fc75a978c25cb39202a6acd7884e58e362b36dd16c446847ca4fe;
        proof[7] = 0x6b4eb4c6e628b555ea79a2232a3ecc8c7bb171d04e1243d26a4cab0e386a5dbc;
        proof[8] = 0xb0b7da5c7ac58f757b28ac52da1741bdfc98efe6130e19047f15e7d05e7cc293;
        proof[9] = 0x7d35c59e73bd5c2eac62271993e328192a430c5d353ce00acf91e1b22633230e;
        proof[10] = 0x93e95585ab898b1f4f4d2423203020411901e265ba0739fcb41b8fbcf41cf0a8;
        proof[11] = 0x314a8fc8b0eda9c598218cdf7273b9eea19059235f5b147569b19ed6a3f257cb;
        proof[12] = 0xe359d272ccfbbcad28662ba8c086e8dc81756f778b9276359faea4b7f5853953;
        proof[13] = 0x2463231b5fe0a32e9d0b53a937935087c1953e4c78e384de86449ee78991d60a;
        proof[14] = 0x9bcf47585f2a931147ca831146eeee9d2057b47d5a1e3cea0ebe6ed37e4f8955;
        proof[15] = 0x508058ec6879a28c912452a300f71f519c8a62f1b57b8774d40eb72548c6d075;
        proof[16] = 0x398475660e48082b852df8270250ba7f4c48f6bac36f7a64750111bdaece6379;
        proof[17] = 0x0f8f079ce040ac6687ad557a79e484285e81b8364ed3cb64e13cbd67bced66d5;
        proof[18] = 0xb4c12a59a5db3a4920c34a0fc60f9233f7674ce42ad803aa8bfb02c34b5735f8;
        proof[19] = 0x5e5eb01dcff3411514d1aeea0fe98ca8d5662baade7f174ce21ace5b8405f71c;
        proof[20] = 0x876e6fe089810a70f38e15ca2b259c5a2e46096a5d9c35ed546f8993f85cb0f2;
        proof[21] = 0xe3ff581afaea2b8e4ef42fe8a94b55fd5ea02aa1d337cf973faa809286437fb5;
        proof[22] = 0xaf2ed0eba528686060d4b89209dab3a2675879b49db108d888403c875896046c;
        proof[23] = 0xeb251806efa665f5fed4893ed89bca233ee9ed6435f67afa519a814700d937bd;
        proof[24] = 0x6bbf47cbd350921fb6ee3ead258a6bedf5e937633a1f2c2f3e0160bf06b0836f;
        proof[25] = 0xf3e83966b275fa7fb256c464678e11dd81ab9a0f174fbfd8a1218f9760ceb866;

        // Leaf is always on the left for index 0, so every sibling is on the right => siblingLeft = false.
        for (uint256 i = 0; i < directions.length; i++) {
            directions[i] = false;
        }
    }

    function testVerifySampleAddress() public view {
        assertTrue(
            verifier.isEligible(SAMPLE_ADDR, proof, directions),
            "sample address should verify"
        );
    }

    function testRejectsWrongAddress() public view {
        address wrong = address(0xBEEF);
        assertFalse(
            verifier.isEligible(wrong, proof, directions),
            "wrong address should fail"
        );
    }

    function testRejectsMutatedProof() public view {
        bytes32[] memory badProof = proof;
        badProof[0] = bytes32(uint256(proof[0]) ^ 1);
        assertFalse(
            verifier.isEligible(SAMPLE_ADDR, badProof, directions),
            "mutated proof should fail"
        );
    }

    function testRejectsLengthMismatch() public {
        bytes32[] memory shortProof = new bytes32[](proof.length - 1);
        bool[] memory shortDirs = new bool[](directions.length);
        bytes32 root = verifier.MERKLE_ROOT();
        vm.expectRevert(MerkleAirdropVerifier.InvalidProof.selector);
        verifier.verifyProof(SAMPLE_LEAF, shortProof, shortDirs, root);
    }

    function testProofFromRustDb() public {
        string[] memory cmd = new string[](3);
        cmd[0] = "python3";
        cmd[1] = "-c";
        cmd[2] = string.concat(
            "import sqlite3, json\n",
            "addr='",
            vm.toString(SAMPLE_ADDR),
            "'\n",
            "addr=addr[2:] if addr.startswith('0x') else addr\n",
            "addr=addr.lower()\n",
            "con=sqlite3.connect('rust.db')\n",
            "cur=con.cursor()\n",
            "row=cur.execute(\"select leaf_idx, leaf_hash from address_index where address=?\", (addr,)).fetchone()\n",
            "idx, leaf = row\n",
            "count=int(cur.execute(\"select value from meta where key='leaf_count'\").fetchone()[0])\n",
            "proof=[]\n",
            "dirs=[]\n",
            "level=0\n",
            "while count>1:\n",
            "    sib_idx = idx ^ 1\n",
            "    cur_hash = cur.execute('select hash from nodes where level=? and idx=?', (level, idx)).fetchone()[0]\n",
            "    sib = cur.execute('select hash from nodes where level=? and idx=?', (level, sib_idx)).fetchone()\n",
            "    sib_hash = sib[0] if sib else cur_hash\n",
            "    proof.append('0x'+sib_hash.hex())\n",
            "    dirs.append(bool(idx & 1))\n",
            "    idx //= 2\n",
            "    count = (count + 1) // 2\n",
            "    level += 1\n",
            "print(json.dumps({'leaf':'0x'+leaf.hex(),'proof':proof,'siblingLeft':dirs}))\n"
        );

        string memory jsonOutput = string(vm.ffi(cmd));
        bytes32 leaf = abi.decode(jsonOutput.parseRaw(".leaf"), (bytes32));
        bytes32[] memory dbProof = abi.decode(jsonOutput.parseRaw(".proof"), (bytes32[]));
        bool[] memory dbDirs = abi.decode(jsonOutput.parseRaw(".siblingLeft"), (bool[]));

        assertTrue(verifier.verifyProof(leaf, dbProof, dbDirs, verifier.MERKLE_ROOT()), "rust.db proof should verify");
        assertTrue(verifier.isEligible(SAMPLE_ADDR, dbProof, dbDirs), "rust.db proof should work via isEligible");
    }
}
