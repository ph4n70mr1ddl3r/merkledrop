#!/usr/bin/env python3
"""
Reconstruct the original sorted file from shard files.

By default, reads shard filenames from shards/manifest.txt (generated by
split_sorted.py) and concatenates them in that order to produce a rebuilt
sorted file.
"""

from __future__ import annotations

import argparse
import sys
import time
import hashlib
from pathlib import Path
from typing import List


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Rebuild sorted file by concatenating shard files in order."
    )
    parser.add_argument(
        "--shard-dir",
        default="shards",
        help="Directory containing shard files and manifest.txt (default: shards)",
    )
    parser.add_argument(
        "--manifest",
        default=None,
        help="Manifest file listing shard filenames in order (default: <shard-dir>/manifest.txt)",
    )
    parser.add_argument(
        "--output",
        default="accounts.txt",
        help="Output file to write reconstructed data (default: accounts.txt)",
    )
    parser.add_argument(
        "--report-every",
        type=float,
        default=5.0,
        metavar="SECONDS",
        help="Seconds between progress updates (default: 5.0)",
    )
    return parser.parse_args()


def load_manifest(path: Path) -> List[Path]:
    if not path.exists():
        sys.exit(f"Manifest not found: {path}")
    shard_files: List[Path] = []
    with open(path, "r", encoding="utf-8") as mf:
        for line in mf:
            name = line.strip()
            if not name:
                continue
            shard_files.append(path.parent / name)
    if not shard_files:
        sys.exit(f"No shard entries found in manifest: {path}")
    return shard_files


EXPECTED_MD5 = "d8d37b2afb096a31a1d26f8347fcfcd5"


def reconstruct(shard_files: List[Path], output_path: Path, report_every: float) -> None:
    for shard in shard_files:
        if not shard.exists():
            sys.exit(f"Shard file missing: {shard}")

    total_bytes = sum(p.stat().st_size for p in shard_files)
    bytes_written = 0
    last_report = time.time()
    md5 = hashlib.md5()

    print(
        f"Reconstructing into {output_path} from {len(shard_files)} shard(s), "
        f"{total_bytes:,} bytes total...",
        file=sys.stderr,
    )

    with open(output_path, "wb") as out_f:
        for shard in shard_files:
            with open(shard, "rb") as in_f:
                for chunk in iter(lambda: in_f.read(1024 * 1024), b""):
                    out_f.write(chunk)
                    md5.update(chunk)
                    bytes_written += len(chunk)
                    now = time.time()
                    if now - last_report >= max(0.5, report_every):
                        percent = (
                            bytes_written / total_bytes * 100 if total_bytes else 100.0
                        )
                        print(
                            f"{percent:5.1f}% | {bytes_written:,} / {total_bytes:,} bytes",
                            file=sys.stderr,
                        )
                        last_report = now

    print(
        f"100.0% | {bytes_written:,} / {total_bytes:,} bytes",
        file=sys.stderr,
    )
    digest = md5.hexdigest()
    if digest == EXPECTED_MD5:
        print(f"Rebuilt file written to {output_path} (md5 OK: {digest})")
    else:
        sys.exit(
            f"Rebuilt file written to {output_path} but md5 mismatch: {digest} "
            f"(expected {EXPECTED_MD5})"
        )


def main() -> None:
    args = parse_args()
    shard_dir = Path(args.shard_dir)
    manifest_path = Path(args.manifest) if args.manifest else shard_dir / "manifest.txt"
    shard_files = load_manifest(manifest_path)
    reconstruct(shard_files, Path(args.output), args.report_every)


if __name__ == "__main__":
    main()
